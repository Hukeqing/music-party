<!DOCTYPE html>

<html>
    <head>
        <script src="src/hls.js"></script>
        <script src="src/js.cookie.js"></script>
        <link rel="stylesheet" href="src/bootstrap-icons.css">
        <link rel="stylesheet" type="text/css" href="src/toastify.min.css">
        <!-- 
            Thanks for jsDelivr providing such amazing libraries
            Some of our users might not able to access through the cdn, so we have to download it to our server
            But we will never forgot where those libraries from and this is for PERSONAL USE ONLY.

            https://cdn.jsdelivr.net/npm/hls.js@1
            https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js
            https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css 
        -->
        <script type="text/javascript">
window.onload = function() {
'use strict';

// SECTION: constants
const FILE_CHUNK_SIZE = 1024 * 1024;
const MEDIA_FRAGMENT_DURATION = 10;
const MAX_RETRY = 3;

// SECTION: icon
const formatIcon = className => `<i class='bi bi-${className}'></i>`;

const Eye = formatIcon('eye');
const EyeSlash = formatIcon('eye-slash');
const SkipStartFill = formatIcon('skip-start-fill');
const SkipEndFill = formatIcon(`skip-end-fill`);
const PauseFill = formatIcon('pause-fill');
const Play = formatIcon('play');
const List = formatIcon('list');
const XLg = formatIcon('x-lg');
const Shuffle = formatIcon('shuffle');
const MusicNoteList = formatIcon('music-note-list');
const Repeat = formatIcon('repeat');
const RepeatOne = formatIcon('repeat-1');
const ListUl = formatIcon('list-ul');
const VolumeUpFill = formatIcon('volume-up-fill');
const VolumeDownFill = formatIcon('volume-down-fill');
const VinylFill = formatIcon('vinyl-fill');
const PencilFill = formatIcon('pencil-fill');

// SECTION: components
const notificationContainer = document.getElementById('notification-container');
const popupContainer = document.getElementById('popup-container');
const popupWindow = document.getElementById('popup-window');
const contextMenuContainer = document.getElementById('context-menu-container');
const main = document.getElementById('main');

// SECTION: notification
const showNotification = (text, className = 'info', duration = 5000) => {
    Toastify({
        text, className, duration,
        close: true, 
        position: "center", gravity: 'bottom'
    }).showToast();
}

// SECTION: popup
let popupWindowVisibility = false;

async function showPopup(buildPage) {
    if(!buildPage) {
        popupContainer.style.backgroundColor = 'unset';
        popupContainer.style.pointerEvents = 'none';
        popupWindow.style.transform = 'scale(0)';
        await new Promise(s=>setTimeout(s, 300));
        popupWindow.innerHTML = '';
        popupWindowVisibility = false;
    } else {
        popupContainer.style.backgroundColor = 'rgba(0,0,0,.7)';
        popupContainer.style.pointerEvents = 'initial';
        buildPage();
        popupWindow.style.transform = 'unset';
        popupWindowVisibility = true;
    }
}
const closePopup = () => showPopup(null);
popupContainer.onclick = evt => {
    if(evt.target === popupContainer) {
        closePopup();
    }
}

// SECTION: context menu
let onTextMenuClose = null;

function showContextMenu(elem, onclose = null) {
    elem.classList.add('context-menu');
    contextMenuContainer.appendChild(elem);
    contextMenuContainer.style.pointerEvents = 'initial';
    onTextMenuClose = onclose;
}
function closeContextMenu() {
    contextMenuContainer.innerHTML = ''
    contextMenuContainer.style.pointerEvents = 'none';
    onTextMenuClose && onTextMenuClose();
    onTextMenuClose = null;
}
contextMenuContainer.onclick = evt => {
    if(evt.target !== contextMenuContainer) return;
    closeContextMenu();
}
contextMenuContainer.oncontextmenu = evt => {
    evt.preventDefault();
    closeContextMenu();
}

// SECTION: utils
function shuffle(arr) {
    return [...arr].sort(()=> .5 - Math.random())
}

// SECTION: pages
function askLogin() {
    if(Cookies.get('session-id')) {
        return party();
    }

    function submitLogin(evt) {
        evt.preventDefault();
        const account = evt.target.account.value;
        const password = evt.target.password.value;
        
        fetch(`/account/login`, {
            method: 'POST',
            body: JSON.stringify({account, password}),
            headers: {'Content-Type': 'application/json'}
        }).then(async res => {
            const { result, sessionID } = await res.json();
            if(result !== 'login-failed') {
                if(result === 'login-success') showNotification('登陆成功!', 'success')
                else if(result === 'account-created') showNotification('注册成功, 将为您登录', 'success')
                Cookies.set('session-id', sessionID, { expires: 365 } );
                if(evt.target['remember-password'].checked) {
                    localStorage.setItem('remember-password', true);
                    localStorage.setItem('account', account);
                    localStorage.setItem('password', password);
                } else if(localStorage.getItem('remember-password')) {
                    localStorage.removeItem('remember-password');
                    localStorage.removeItem('account');
                    localStorage.removeItem('password');
                }
                // go to party main
                party();
            } else {
                showNotification('密码不正确!', 'err')
            }
        })
    }

    main.innerHTML = `
    <form id='login-form'>
        <span class='description'>请输入账号密码登录，如果账号不存在将会直接创建</span>
        <input type='text' name='account' id='login-account' placeholder="请输入您的账号" >
        <div id='show-password' class='clickable'>${Eye}</div>
        <input type='password' name='password' id='login-password' placeholder='请输入您的密码' >
        <div class='remember-password-container'>
            <input type='checkbox' id='remember-password' name='remember-password'>
            <span>记住密码</span>
        </div>
        <button class='clickable' type='submit'>登录</button>
    </form>
    `

    let password_display = false;
    const password_elem = document.getElementById('login-password');
    const show_password_elem = document.getElementById('show-password');

    if(localStorage.getItem('remember-password')) {
        password_elem.value = localStorage.getItem('password');
        document.getElementById('login-account').value = localStorage.getItem('account');
        document.getElementById('remember-password').checked = true;
    }

    show_password_elem.onclick = () => {
        password_display = !password_display;
        show_password_elem.innerHTML = password_display ? EyeSlash : Eye;
        password_elem.type = password_display ? 'text' : 'password';
    }
    document.getElementById('login-form').onsubmit = submitLogin;
}

async function party() {
    const sessionID = Cookies.get('session-id')
    // validate current login information
    const user_login_validated = await (await fetch(`/account/validate-login`,{
        method: 'POST',
        body: JSON.stringify({ sessionID }),
        headers: { 'Content-Type': 'application/json' }
    })).json();
    if(!user_login_validated) {
        showNotification('登陆凭证已过期!', 'warn')
        Cookies.remove('session-id');
        return askLogin();
    }

    // check hls capability, if not capable return to login page
    let HLSType = null;

    (function () {
        if(document.createElement('video').canPlayType('application/x-mpegURL')) {
            HLSType = 'browser'
        } else if(Hls.isSupported()) {
            HLSType = 'library'
        } else {
            Cookies.remove('session-id');
            askLogin();
            showNotification('您的浏览器似乎不支持通过HLS播放!')
        }
    })();


    // init states
    const PLAY_WAYS = ['loop', 'single', 'random', 'playlist']

    let displaying = {
        type: '', elem: null, currentVolume: 0.5
    }

    const playStates = {
        playlist: {},
        playing: -1, order: [],
        random_order: [],
        _how: 'loop',
        set how(way) {
            how_to_play.innerHTML = 
                way === 'playlist' ? ListUl :
                way === 'single' ? RepeatOne : 
                way === 'random' ? Shuffle : 
                Repeat
            
            const playing_id = getFollowOrder()[this.playing]
            if(way === 'random') this.random_order = shuffle(this.order)
            this._how = way;
            this.playing = getFollowOrder().indexOf(playing_id)
        },
        get how() {
            return this._how;
        }
    }
    
    let last_toggled_resize = 0;
    let manual_update_media_time = false,
        manual_toggle_play = false,
        can_sync_media_time = false;
    let pause_after = 0;
    
    const roomMode = { 
        activate: false, playlist: {}, order: [], extra: {},
        syncProgress: null, exitRoom: null, requestUpdatePlaylist: null
    };

    // functions
    function createHLSController(bound_elem, type) {
        let hls;
        if(HLSType === 'library') {
            hls = new Hls();
            hls.attachMedia(bound_elem);
        }

        return function(url) {
            if(HLSType === 'browser') {
                bound_elem.src = url;
            } else if(HLSType === 'library') {
                hls.loadSource(url);
            }
        }
    }

    function loadHls(bound_elem, type) {
        const hls = createHLSController(bound_elem, type);

        return async (url, startPlay)=>{
            hls(url)
            if(displaying.type !== type) {
                if(displaying.elem) {
                    displaying.elem.style.display = 'none';
                    displaying.elem.pause();
                    displaying.type = type;
                }
                displaying.elem = bound_elem;
                bound_elem.style.display = 'block';
            }
            startPlay && bound_elem.play();
            bound_elem.volume = displaying.currentVolume;
        }
    }

    function getMediaDuration(media_file, fileType) {
        return new Promise(resolve => {
            const media_elem = document.createElement(fileType);
            const url = URL.createObjectURL(media_file);
            media_elem.preload = 'metadata';
            media_elem.onloadedmetadata = () => {
                resolve(media_elem.duration);
                URL.revokeObjectURL(url);
            }
            media_elem.src = url;
        })
    }

    function getFollowOrder() {
        return (
            roomMode.activate ? roomMode.order : 
            playStates.how === 'random' ? playStates.random_order : 
            playStates.order
        )
    }

    async function uploadFile(file, rename, progressControl) {
        let totalChunks = Math.ceil(file.size / FILE_CHUNK_SIZE), 
            currentChunkIndex = 0,
            fileType = file.type.split('/').shift(),
            referenceID = -1, 
            updateProgress = progressControl(abort),
            retry = 0, pauseUpdateTill = 0;

        async function init() {
            const estFragments = Math.ceil((await getMediaDuration(file, fileType)) / MEDIA_FRAGMENT_DURATION);
            referenceID = + (await (await fetch('/playlist/pre-upload', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    sessionID,
                    title: (rename || file.name),
                    suffix: file.name.split('.').pop(),
                    fileType,
                    estChunks: totalChunks,
                    estFragments
                })
            })).text());
            cutFileChunk();
        }

        async function abort() {
            if(currentChunkIndex !== -1 && referenceID !== -1) {
                currentChunkIndex = -1;
                const abort_result = await (await fetch(`/playlist/`, {
                    method: 'DELETE',
                    body: JSON.stringify({id: referenceID, sessionID}),
                    headers: {'Content-Type': 'application/json'},
                })).json()
                
                updateProgress(`aborted${abort_result ? '' : '-failed'}`);
                if(!abort_result) {
                    pauseUpdateTill = Date.now() + 5000
                }
            }
        }

        function cutFileChunk() {
            if(currentChunkIndex < 0) return;

            const start = currentChunkIndex * FILE_CHUNK_SIZE;
            const end = Math.min(start + FILE_CHUNK_SIZE, file.size);
            sendFileChunk(file.slice(start, end));
        }

        async function sendFileChunk(chunk) {
            if(currentChunkIndex < 0) return;

            const isLastChunk = + (currentChunkIndex === totalChunks - 1)
            const searchParams = new URLSearchParams({
                sessionID, referenceID, chunkIndex: currentChunkIndex
            })

            const upload_result = await (await fetch(`/playlist/upload-chunk?${searchParams.toString()}`, {
                method: 'POST',
                body: chunk,
                headers: {'Content-Type': 'application/octet-stream'}
            })).json();

            if(upload_result) {
                if(isLastChunk) {
                    currentChunkIndex = -1;
                    updateProgress('waiting-process', 0);
                    const interval_id = setInterval(async () => {
                        const fragment_status = await getUploadProgress(referenceID);
                        if(pauseUpdateTill) {
                            if(Date.now() <= pauseUpdateTill) return;
                            pauseUpdateTill = 0;
                        }
                        if(!fragment_status.error_msg) {
                            updateProgress(
                                fragment_status.status === 'fragmenting' ?
                                'waiting-process' :
                                fragment_status.status === 'finished' ?
                                'finished' : 'upload', Math.floor(fragment_status.progress * 100))
                        }
                        (!popupWindowVisibility || fragment_status.error_msg || fragment_status.status === 'finished') && clearInterval(interval_id)
                    }, 1000);
                } else if(currentChunkIndex >= 0) {
                    currentChunkIndex ++;
                    updateProgress('upload', Math.floor((currentChunkIndex / (totalChunks - 1)) * 100))
                    cutFileChunk();
                }
            } else {
                if(retry < MAX_RETRY) {
                    retry ++;
                    cutFileChunk()
                    updateProgress('retry', retry)
                } else {
                    retry = 0;
                    updateProgress('failed')
                }
            }
        }

        init();
    }

    async function getPlaylist() {
        const user_playlists = await (await fetch(
            `/playlist/user-playlist?${new URLSearchParams({sessionID}).toString()}`)
        ).json()
        const updatedIDs = user_playlists.map(e=>e.id);

        const playing_id = getFollowOrder()[playStates.playing]
        let removed_playing = false;
        // check if any media removed
        Object.keys(playStates.playlist).filter(e=>! (+e in updatedIDs))
        .forEach(removedMedia => {
            let media_id = +removedMedia;
            if(playing_id === media_id) removed_playing = true;
            playStates.order = playStates.order.filter(e => e !== media_id);
            delete playStates.playlist[media_id];
            if(roomMode.activate) {
                roomMode.order = roomMode.order.filter(e => e !== media_id);
                delete roomMode.playlist[media_id];
            }
        })

        // update details and add any media not added
        for(const media of user_playlists) {
            playStates.playlist[media.id] = media;
            playStates.order.includes(media.id) || playStates.order.push(media.id);

            roomMode.activate &&
            (roomMode.order.includes(media.id) || roomMode.order.push(media.id));
        }

        roomMode.activate && roomMode.requestUpdatePlaylist();
        if(removed_playing) {
            playStates.playing = 0;
            playMedia({manualPlay: true, startPlay: !displaying.elem.paused});
        } else {
            playStates.playing = getFollowOrder().indexOf(playing_id);
        }
        return;
    }

    async function getUploadProgress(referenceID = -1) {
        const url = referenceID > 0 ? 'media' : 'user'
        const query = { sessionID }
        if(referenceID > 0) query.referenceID = referenceID;
        return await (
            await fetch(
                `/playlist/${url}-upload-status?${new URLSearchParams(query).toString()}`
            )
        ).json()
    }

    function togglePlay() {
        if(displaying.elem) {
            displaying.elem.paused ? displaying.elem.play() : displaying.elem.pause();
        } else if(((roomMode.activate && roomMode.order.length) || playStates.order.length) && playStates.playing === -1) {
            playNext(false);
        }
        manual_toggle_play = true;
    }

    function playMedia({manualPlay = false, startPlay = true}) {
        const media_list = roomMode.activate ? roomMode.playlist : playStates.playlist
        const media = media_list[getFollowOrder()[playStates.playing]]
        media.type === 'audio' ?
            setAudioHls(`/playlist/${sessionID}/${media.id}/${media.filename}.m3u8`, startPlay) :
            setVideoHls(`/playlist/${sessionID}/${media.id}/${media.filename}.m3u8`, startPlay)

        if(media.type === 'audio') {
            audio_title_container.style.display = 'block';
            audio_title.textContent = media.title;
            audio_title.style.animationName = 'unset';
            audio_title.style.animationDuration = `${
                Math.max(
                    audio_title.clientWidth, 
                    audio_title_container.clientWidth
                ) / 70}s`;
            audio_title.style.animationName = 'music-title-scroll';

        } else {
            audio_title_container.style.display = 'none';
        }

        if(roomMode.activate && manualPlay) roomMode.syncProgress()
    }

    function playNext(manual = true) {
        if(!(roomMode.activate && roomMode.order.length) && !playStates.order.length) return;
        if(playStates.how === 'single') {
            playMedia({manualPlay: manual}); return;
        }
        const followOrder = getFollowOrder();
        // if is last
        if(playStates.playing >= followOrder.length - 1) {
            if(playStates.how === 'playlist') return;
            playStates.playing = 0;
            if(playStates.how === 'random')
                playStates.random_order = shuffle(playStates.order)
        } else playStates.playing ++;
        playMedia({manualPlay: manual});
    }

    function playLast() {
        if((!(roomMode.activate && roomMode.order.length) && !playStates.order.length)) return;
        if(playStates.how === 'single') {
            playMedia({manualPlay: true}); return;
        }
        const followOrder = getFollowOrder();
        // if is first
        if(playStates.playing <= 0) {
            if(playStates.how === 'playlist') return;
            else playStates.playing = followOrder.length - 1
        } else playStates.playing --;
        playMedia({manualPlay: true});
    }

    function keyboardControl(evt) {
        // disable keyboard control when there's a popup window
        if(popupWindowVisibility || document.activeElement === displaying.elem) return;

        switch(evt.key) {
            case ' ': togglePlay(); break;
            case 'ArrowLeft': calculateSetProgressByTime(-5); break;
            case 'ArrowRight': calculateSetProgressByTime(5); break;
            case 'ArrowUp': setVolume(0.02); break;
            case 'ArrowDown': setVolume(-0.02); break;
            default: break;
        }
    }

    function interactableProgressBar(name, setElemProgress) {
        const states = { mouseDown: false, X: -1, width: -1, locOnPage: -1 }
        const container = document.querySelector(`#media-${name}-interactive.media-interactive-container`);
        const bar = document.querySelector(`#media-${name}-interactive.media-interactive-container .bar .bg`)
        const node = document.querySelector(`#media-${name}-interactive.media-interactive-container #node`)
        // read layout property to force render
        container.offsetWidth;

        container.onmousedown = () => {states.mouseDown = true}
        container.onmouseup = () => {
            if(name==='progress') can_sync_media_time = true;
            states.mouseDown = false
        }
        container.onmouseleave = () => {
            if(name==='progress' && states.mouseDown)
                can_sync_media_time = true;
            states.mouseDown = false
        }
        container.ontouchstart = () => {states.mouseDown = true}
        container.ontouchend = () => {
            if(name==='progress') can_sync_media_time = true;
            states.mouseDown = false
        }
        container.ontouchcancel = () => {
            if(name==='progress' && states.mouseDown)
                can_sync_media_time = true;
            states.mouseDown = false
        }
        container.onclick = evt => {
            states.X = evt.offsetX;
            calculateProgress(null, true);
        }
        container.onmousemove = evt => {
            states.X = evt.offsetX;
            states.mouseDown && calculateProgress(null, true);
        }
        container.ontouchmove = evt => {
            states.X = evt.changedTouches[0].pageX - states.locOnPage;
            states.mouseDown && calculateProgress(null, true);
        }
        function setUIProgress() {
            bar.style.transform = `translateX(${states.X}px)`;
            node.style.transform = `translateX(${states.X}px)`;
        }

        function updateWidth() {
            states.width = container.offsetWidth;
            states.locOnPage = container.getBoundingClientRect().left
        }

        function calculateProgress(params = {value: null, total: null}, isInside = false) {
            states.X = Math.max(Math.min(states.width, states.X), 0)
            if(isInside) {
                setElemProgress(states.X / states.width);
            } else {
                const {value, total} = params;
                states.X = Math.round(states.width * (value / total));
                setUIProgress()
            }
        }

        updateWidth();

        return [calculateProgress, updateWidth]
    }

    function windowResized() {
        if(Date.now() - last_toggled_resize < 100) return;
        last_toggled_resize = Date.now();

        updateMediaProgressWidth();
        updateMediaVolumeWidth();
        checkPartyOverflow();
    }
    
    function checkPartyOverflow() {
        // check observers to determine overflow
        if(
            top_observer.getBoundingClientRect().top < 0 ||
            bottom_observer.getBoundingClientRect().top > party_page.offsetHeight
        ) {
            party_page.style.overflowY = 'scroll';
        } else {
            party_page.style.overflowY = 'hidden';
        }
    }

    function calculateSetProgressByTime(time = 0) {
        if(!displaying.elem) return;
        let duration = displaying.elem.duration,
            currentTime = displaying.elem.currentTime;
        time = Math.max(Math.min(currentTime + time, duration), 0);
        displaying.elem.currentTime = time;
        can_sync_media_time = true;
    }

    function setVolume(change) {
        if(!displaying.elem) return;
        const newVol = Math.max(Math.min(displaying.currentVolume + change, 1), 0);
        displaying.elem.volume = newVol;
    }
    
    function updatePlayIcon() {
        if(displaying.elem) {
            if(displaying.elem.paused) {
                toggle_play_btn.innerHTML = Play;
                toggle_play_btn.title = '播放';
            } else {
                toggle_play_btn.innerHTML = PauseFill;
                toggle_play_btn.title = '暂停';
            }
        }
        roomMode.activate && manual_toggle_play && roomMode.syncProgress();
        manual_toggle_play = false;
    }

    function pauseTimerAction() {
        if(displaying.elem) {
            manual_toggle_play = true;
            displaying.elem.pause();
        }
        pause_after = 0;
    }

    function mediaElemEvtListeners() {
        let media_time_update_cooldown = 0;

        function mediaVolumeChanged() {
            displaying.currentVolume = displaying.elem.volume;
            calculateMediaVolume({
                value:  displaying.currentVolume,
                total: 1
            })
        }
        function mediaTimeUpdated() {
            const current = Date.now();
            if(pause_after && current >= pause_after) {
                pauseTimerAction();
            }
            if(current < media_time_update_cooldown && !manual_update_media_time) return;
            media_time_update_cooldown = current + 100;

            if(can_sync_media_time && roomMode.activate) roomMode.syncProgress();

            manual_update_media_time = false;
            can_sync_media_time = false;

            if(displaying.elem) {
                calculateMediaProgress({
                    value: displaying.elem.currentTime,
                    total: displaying.elem.duration
                })
            }
        }

        video_component.onended = playNext;
        audio_component.onended = playNext;

        video_component.onvolumechange = mediaVolumeChanged;
        audio_component.onvolumechange = mediaVolumeChanged;
        
        video_component.onpause = updatePlayIcon;
        audio_component.onpause = updatePlayIcon;
        video_component.onplay = updatePlayIcon;
        audio_component.onplay = updatePlayIcon;

        video_component.ontimeupdate = mediaTimeUpdated;
        audio_component.ontimeupdate = mediaTimeUpdated;
    }

    function updateTextScrollAnimation(elem, parentElem = null, pauseAfterFinish = 2000, speed = 70) {
        parentElem = parentElem || elem.parentElement;

        let not_available = elem.offsetWidth <= parentElem.offsetWidth,
            moveDistance = elem.offsetWidth - parentElem.offsetWidth + 10,
            last_update_time = Date.now(),
            play_end = false,
            position = 0;
        
        function move() {
            not_available || requestAnimationFrame(move)
            const time_past = Date.now() - last_update_time;
            if(!play_end) {
                elem.style.transform = `translateX(${Math.floor(position)}px)`;
                position -= last_update_time < 0 ? 0 : time_past / 1000 * speed;
                last_update_time = Date.now();
                if(Math.abs(position) > moveDistance) {
                    play_end = true;
                    position = 0;
                }
            } else if(time_past >= pauseAfterFinish) {
                play_end = false;
                last_update_time = Date.now();
            }
        }
        not_available || requestAnimationFrame(move)

        return function requestUpdate() {
            const previous_available = not_available;
            not_available = elem.offsetWidth <= parentElem.offsetWidth;
            moveDistance = elem.offsetWidth - parentElem.offsetWidth + 10;
            last_update_time = Date.now();
            play_end = false;
            position = 0;

            !not_available && !previous_available && requestAnimationFrame(move)
        }
    }

    // main page
    main.innerHTML = `
    <div id='party'>
        <div class='overflow-observer' name='top-observer'></div>
        <div class='party-main'>
            <div class='media-container-block'>
                <div class='media-container'>
                    <div class='music-title-container'>
                        <div class='music-title'><div class='music-title-text'></div></div>
                        ${VinylFill}
                    </div>
                    <video id='video-component' controls></video>
                    <audio id='audio-component'></audio>
                </div>
            </div>
            <div id='media-progress-interactive' class='media-interactive-container clickable'>
                <div class='bar'><div class='bg'></div></div>
                <div id='node'></div>
            </div>
            <div class='controllers'>
                <div class='controller clickable sub-icon' id='show-playlist-icon' title='播放列表'>${MusicNoteList}</div>
                <div class='controller clickable' id='last' title='上一媒体'>${SkipStartFill}</div>
                <div class='controller clickable' id='toggle-play' title='播放'>${Play}</div>
                <div class='controller clickable' id='next' title='下一媒体'>${SkipEndFill}</div>
                <div class='controller clickable sub-icon' id='how-to-play' title='切换播放方式'>${Repeat}</div>
            </div>
            <div id='media-volume-interactive' class='media-interactive-container clickable'>
                ${VolumeDownFill}
                <div class='bar'><div class='bg'></div></div>
                <div id='node'></div>
                ${VolumeUpFill}
            </div>
        </div>
        <div id='nav-bar'>
            <div class='clickable' id='hamburger-icon'>${List}</div>
            <div class='items'>
                <div class='item clickable' id='user-center'><div>用户中心</div></div>
                <div class='item clickable' id='get-playlist'><div>播放列表</div></div>
                <div class='item clickable' id='pause-timer'><div>定时关闭</div></div>
                <div class='item clickable' id='upload-media'><div>上传媒体文件</div></div>
                <div class='item clickable' id='upload-manager'><div>管理我的上传</div></div>
                <div class='item clickable' id='join-room-menu'><div>创建/加入房间</div></div>
                <div class='item clickable' id='update-playlist'><div>更新播放列表</div></div>
                <div class='item clickable' id='logout'><div>退出登录</div></div>
            </div>
        </div>
        <div class='overflow-observer' name='bottom-observer'></div>
    </div>`

    // components on main page
    const video_component = document.getElementById('video-component');
    const audio_component = document.getElementById('audio-component');
    const audio_title_container = document.querySelector('.media-container .music-title-container')
    const audio_title = document.querySelector('.media-container .music-title-container .music-title .music-title-text')
    
    // observers and references
    const top_observer = document.querySelector('.overflow-observer[name="top-observer"]');
    const bottom_observer = document.querySelector('.overflow-observer[name="bottom-observer"]');
    const party_page = document.getElementById('party');

    const setVideoHls = loadHls(video_component, 'video');
    const setAudioHls = loadHls(audio_component, 'audio');

    const toggle_play_btn = document.getElementById('toggle-play')
    const how_to_play = document.getElementById('how-to-play')

    // listeners
    mediaElemEvtListeners();

    toggle_play_btn.onclick = togglePlay;
    document.getElementById('last').onclick = playLast
    document.getElementById('next').onclick = playNext
    document.getElementById('show-playlist-icon').onclick = () => showPopup(showPlaylist)
    how_to_play.onclick = function() {
        if((!(roomMode.activate && roomMode.order.length) && !playStates.order.length)) return;
        const idx = PLAY_WAYS.indexOf(playStates.how)
        playStates.how = PLAY_WAYS[idx === PLAY_WAYS.length - 1 ? 0 : idx + 1]

        if(roomMode.activate) {
            roomMode.requestUpdatePlaylist(true);
        }
    }
    
    window.addEventListener('resize', windowResized);
    document.addEventListener('keydown', keyboardControl)
    
    const [calculateMediaProgress, updateMediaProgressWidth] = interactableProgressBar('progress', value => {
        manual_update_media_time = true;
        if(displaying.elem) displaying.elem.currentTime = displaying.elem.duration * value;
    })
    const [calculateMediaVolume, updateMediaVolumeWidth] = interactableProgressBar('volume', value => {
        if(displaying.elem) displaying.elem.volume = value;
    })
    

    // nav bar
    const nav_bar = document.getElementById('nav-bar');
    document.getElementById('hamburger-icon').onclick = () => {
        nav_bar.classList.toggle('expanded-nav-bar')
    }
    
    // nav bar items
    function uploadMediaFile() {
        popupWindow.innerHTML = `
        <div id='upload-media-container'>
            <div class='upload-file-container'>
                <input type='file' name='media-files' id='files-input' class='clickable' multiple>
                <div class='show-upload'><span>点击或拖拽文件到此处以上传</span></div>
            </div>
            <div class='btn-container'>
                <button id='upload-btn'>上传</button>
                <button id='cancel-btn'>取消</button>
            </div>
        </div>
        `

        function updateProgress(playlist_name, elem, bgElem, stats) {
            let updateAnimation = updateTextScrollAnimation(elem)
            const updatedAnimation = {
                'upload': false,
                'waiting-process': false
            }
            return function(abort) {
                stats.abort = abort;
                return function(progress, additional = null) {
                    if(progress === 'finished') getPlaylist()

                    const msg = 
                        progress === 'upload' ? `[${playlist_name}] 上传中... ${`${additional}`.padStart(2, '0')}%` :
                        progress === 'waiting-process' ? `[${playlist_name}] 生成分片文件中... ${`${additional}`.padStart(2, '0')}%` :
                        progress === 'finished' ? `[${playlist_name}] 上传完成!` : 
                        progress === 'aborted' ? `[${playlist_name}] 上传中断!` : 
                        progress === 'aborted-failed' ? `[${playlist_name}] 上传无法中断, 请等待上传完成后手动删除!` : 
                        progress === 'failed' ? `[${playlist_name}] 上传重试${MAX_RETRY}次后失败, 请尝试重新上传或联系管理员!` : 
                        progress === 'retry' ? `[${playlist_name}] 上传失败, 重试第${additional}次.` : 
                        ''

                    if(!popupWindowVisibility) {
                        if(progress === 'upload' || progress === 'waiting-process') return;
                        
                        showNotification(
                            msg,
                            progress === 'aborted' || progress === 'failed' ? 'err' : 
                            progress === 'aborted-failed' || progress === 'retry' ? 'warn' : 
                            'success'
                        )
                        return;
                    } else {
                        elem.textContent = msg;

                        bgElem.style.backgroundColor = 'lightgreen';
                        elem.style.color = `black`;

                        if(progress === 'upload' || progress === 'waiting-process') {
                            bgElem.style.transform = `translateX(-${100 - additional}%)`
                            if(!updatedAnimation[progress]) {
                                updatedAnimation[progress] = true;
                                updateAnimation();
                            }
                            return;
                        } else if(progress === 'retry') {
                            bgElem.style.backgroundColor = `gold`;
                            updatedAnimation['upload'] = false;
                            updatedAnimation['waiting-process'] = false;
                        } else {
                            bgElem.style.transform = 'translateX(0)';
                            stats.finished = true;
                            switch(progress) {
                                case 'finished': break;
                                case 'aborted':
                                case 'failed':
                                    bgElem.style.backgroundColor = `red`;
                                    elem.style.color = `white`;
                                    break;
                                case 'aborted-failed':
                                    bgElem.style.backgroundColor = `gold`;
                                    break;
                                default: stats.finished = false;
                            }
                        }
                        updateAnimation();
                        return;
                    }
                }
            }
        }

        const uploadMediaContainer = document.getElementById('upload-media-container'),
                uploadBtn = document.getElementById('upload-btn'),
                cancelBtn = document.getElementById('cancel-btn')

        const selectedFiles = []

        const filesInput = document.getElementById('files-input')
        filesInput.onchange = evt => {
            const files = evt.target.files;
            const all_files_index = selectedFiles.length

            for(var i = 0, j = all_files_index; i < files.length; i ++, j ++) {
                const file = files[i];
                if(! /^(audio|video)\/.*$/.test(file.type)) {
                    showNotification(`[${file.name}]不是视频/音频文件！`, 'err');
                    j --;
                    continue;
                }
                const index = j;

                const displayElemContainer = document.createElement('div');
                displayElemContainer.className = 'progress-bar';

                const defaultName = file.name.split('.').slice(0, -1).join('.')
                
                const renameInput = document.createElement('input')
                renameInput.type = 'text';
                renameInput.placeholder = defaultName;
                renameInput.value = defaultName;
                renameInput.oninput = evt => {
                    const value = evt.target.value;
                    selectedFiles[index].rename = value;
                }

                const removeFile = document.createElement('div')
                removeFile.className = 'remove-file clickable';
                removeFile.innerHTML = XLg;
                removeFile.onclick = () => {
                    selectedFiles.splice(index, 1, null);
                    displayElemContainer.remove();
                }

                displayElemContainer.appendChild(renameInput);
                displayElemContainer.appendChild(removeFile);
                uploadBtn.parentElement.insertAdjacentElement('beforebegin', displayElemContainer)

                selectedFiles[index] = {
                    rename: defaultName, finished: false,
                    file, displayElemContainer
                }
            }
        }

        function cleanUp() {
            selectedFiles.length = 0;
            closePopup();
        }

        uploadBtn.onclick = () => {
            filesInput.disabled = true;
            const finishBtn = document.createElement('button');
            finishBtn.onclick = () => {
                if(!selectedFiles.filter(e=>!e.finished).length) {
                    cleanUp()
                } else {
                    showNotification('还有未完成上传的文件!', 'err');
                }
            }
            finishBtn.textContent = '完成';
            uploadBtn.insertAdjacentElement('beforebegin', finishBtn)
            uploadBtn.remove();
            cancelBtn.onclick = () => {
                const isAllFinished = !selectedFiles.filter(e=>!e.finished).length
                if(!isAllFinished) {
                    selectedFiles.forEach(e=>{
                        e && e.abort && e.abort();
                    })
                    cancelBtn.onclick = cleanUp;
                } else cleanUp();
            }

            selectedFiles.forEach(e=>{
                if(!e) return;

                const { file, rename, displayElemContainer } = e;
                displayElemContainer.innerHTML = '';

                const progress_background = document.createElement('div')
                progress_background.className = 'progress-background';
                displayElemContainer.appendChild(progress_background)

                const progress_text = document.createElement('div')
                progress_text.className = 'progress-text';
                progress_text.textContent = `[${rename || file.name}] 等待上传中...`;
                displayElemContainer.appendChild(progress_text)

                uploadFile(file, rename, updateProgress(rename||file.name, progress_text, progress_background, e));
            })
        }

        cancelBtn.onclick = cleanUp;
    }
    function showPlaylist() {
        let bulk_select_mode = false, selected_all = false;
        let selectedPlaylists = {}
        let bulkSelectBtns = { bulkSelect: null, bulkSelectAll: null }

        function startBulkSelect(elem = null) {
            bulk_select_mode = true;
            elem && elem.click();
        }

        function endBulkSelect(removeElem = false) {
            bulk_select_mode = false;
            document.querySelectorAll('.media.bulk-selected')
            .forEach(e=>removeElem ? e.remove() : e.classList.remove('bulk-selected'));
            selectedPlaylists = {};
        }

        function clearBulkSelectBtns() {
            bulkSelectBtns = { bulkSelect: null, bulkSelectAll: null }
        }

        function updateBtnText() {
            selected_all = Object.keys(selectedPlaylists).length === loading_playlist_order.length

            if(bulkSelectBtns.bulkSelect) {
                bulkSelectBtns.bulkSelect.textContent = 
                    bulk_select_mode ? '取消批量选择' : '批量选择';
            }
            if(bulkSelectBtns.bulkSelectAll) {
                bulkSelectBtns.bulkSelectAll.textContent =
                    selected_all ? '取消全选' : '全选'
            }
        }

        function musicContextMenu(evt, id, index) {
            evt.preventDefault && evt.preventDefault();
            
            const contextMenu = document.createElement('div');
            contextMenu.className = 'playlist-context-menu'
            contextMenu.style.left = `${evt.pageX}px`;
            contextMenu.style.top = `${evt.pageY}px`;

            const removeFromPlaylist = document.createElement('div');
            removeFromPlaylist.className = 'item'
            removeFromPlaylist.textContent = '删除'
            removeFromPlaylist.onclick = () => {
                if(playStates.how === 'random') {
                    showNotification('当前播放顺序为随机顺序, 无法进行删除!', 'warn');
                    return;
                }
                if(!bulk_select_mode) {
                    if(!evt.target) {
                        showNotification('请使用批量选择模式进行删除!')
                        return;
                    }
                    bulk_select_mode = true;
                    evt.target.click();
                }

                let modifying_order = roomMode.activate ? roomMode.order: playStates.order;
                const playing_id = modifying_order[playStates.playing];
                
                modifying_order[playStates.playing] = -1;

                for(const idx in selectedPlaylists) {
                    modifying_order[idx] = null;
                }

                modifying_order = modifying_order.filter(e=>e !== null);
                if(roomMode.activate) roomMode.order = modifying_order
                else playStates.order = modifying_order

                modifying_order = roomMode.activate ? roomMode.order: playStates.order;
                const playingIdx = modifying_order.indexOf(-1)
                if(playingIdx >= 0) {
                    modifying_order[playingIdx] = playing_id;
                    playStates.playing = playingIdx;
                } else {
                    playStates.playing = 0;
                    playMedia({startPlay: displaying.elem && !displaying.elem.paused})
                }

                roomMode.activate && roomMode.requestUpdatePlaylist();

                endBulkSelect(true);
                closeContextMenu();
                if(!playStates.order.length) showPlaylist();
            }

            const moveToFront = document.createElement('div');
            moveToFront.className = 'item';
            moveToFront.textContent = '移动到最前面';
            moveToFront.onclick = () => {
                if(playStates.how === 'random') {
                    showNotification('当前播放顺序为随机顺序, 无法更改排序!', 'warn');
                    return;
                }
                if(!bulk_select_mode) {
                    if(!evt.target) {
                        showNotification('请使用批量选择模式进行移动!')
                        return;
                    }
                    bulk_select_mode = true;
                    evt.target.click();
                }
                let modifying_order = roomMode.activate ? roomMode.order : playStates.order
                let playing_id = -1;
                if(playStates.playing >= 0) {
                    playing_id = modifying_order[playStates.playing]
                    if(Object.keys(selectedPlaylists).includes(`${playStates.playing}`)) {
                        selectedPlaylists[playStates.playing] = -1;
                    } else {
                        modifying_order[playStates.playing] = -1;
                    }
                }

                for(const idx in selectedPlaylists) {
                    modifying_order[idx] = null;
                }
                const moved_playlists = Object.values(selectedPlaylists).concat(modifying_order.filter(e=>e!==null));

                if(roomMode.activate) roomMode.order = moved_playlists
                else playStates.order = moved_playlists

                modifying_order = roomMode.activate ? roomMode.order : playStates.order
                if(playing_id >= 0) {
                    const playingIdx = modifying_order.indexOf(-1)
                    modifying_order[playingIdx] = playing_id;
                    playStates.playing = playingIdx;
                }
                roomMode.activate && roomMode.requestUpdatePlaylist()

                endBulkSelect(true);
                closeContextMenu();
                showPlaylist();
            }

            const bulkSelect = document.createElement('div')
            bulkSelect.className = 'item';
            bulkSelect.onclick = () => {
                if(bulk_select_mode) {
                    endBulkSelect();
                } else {
                    startBulkSelect(evt.target);
                }
                updateBtnText();
            }

            const bulkSelectAll = document.createElement('div')
            bulkSelectAll.className = 'item';
            bulkSelectAll.onclick = () => {
                if(selected_all) {
                    endBulkSelect();
                    bulk_select_mode = true;
                } else {
                    bulk_select_mode = true;
                    document.querySelectorAll('#popup-window #playlist-main .media:not(.bulk-selected)')
                    .forEach(e=>e.click());
                }
            }

            const cancelOperate = document.createElement('div')
            cancelOperate.className = 'item';
            cancelOperate.textContent = '取消';
            cancelOperate.onclick = closeContextMenu;

            bulkSelectBtns = { bulkSelect, bulkSelectAll }
            updateBtnText();

            contextMenu.appendChild(removeFromPlaylist)
            contextMenu.appendChild(moveToFront)
            contextMenu.appendChild(bulkSelect)
            contextMenu.appendChild(bulkSelectAll)
            contextMenu.appendChild(cancelOperate)

            showContextMenu(contextMenu, clearBulkSelectBtns)
            contextMenu.style.left = `${evt.pageX}px`
            contextMenu.style.top = `${evt.pageY}px`
            if(contextMenuContainer.offsetWidth - (evt.pageX + contextMenu.offsetWidth) < 0) {
                contextMenu.style.left = `${evt.pageX - contextMenu.offsetWidth}px`;
            }
            contextMenu.offsetWidth;
            contextMenu.style.transitionDuration = '.5s';
            contextMenu.style.transform = 'scaleY(1)';
        }

        if(popupWindowVisibility) popupWindow.innerHTML = ''

        const playlist_main = document.createElement('div')
        playlist_main.id = 'playlist-main'

        const editPlaylistBtn = document.createElement('div');
        editPlaylistBtn.className = 'edit-playlist clickable'
        editPlaylistBtn.innerHTML = PencilFill
        playlist_main.appendChild(editPlaylistBtn);
        editPlaylistBtn.onclick = evt => {
            const {top, left, height} = evt.target.getBoundingClientRect();
            musicContextMenu({pageX: left, pageY: top + height}, null, null)
        }
        
        const loading_playlist_order = getFollowOrder();
        const loading_playlist = roomMode.activate ? roomMode.playlist : playStates.playlist
        if(loading_playlist_order.length) {
            loading_playlist_order.forEach((id, index)=>{
                const media = loading_playlist[id];
                if(!media) return;

                const playBtn = document.createElement('div');
                playBtn.className = 'media clickable'
                index === playStates.playing && playBtn.classList.add('playing')

                const playBtnText = document.createElement('div')
                playBtnText.className = 'title-text';
                playBtnText.textContent = media.title;
                
                playBtn.onclick = () => {
                    if(bulk_select_mode) {
                        if(selectedPlaylists[index]) {
                            delete selectedPlaylists[index];
                            playBtn.classList.remove('bulk-selected')
                        } else {
                            selectedPlaylists[index] = id;
                            playBtn.classList.add('bulk-selected');
                        }
                        updateBtnText();
                    } else {
                        const last_playing = document.querySelector('#popup-window #playlist-main .media.playing')
                        last_playing && last_playing.classList.remove('playing')
                        playBtn.classList.add('playing')
                        playStates.playing = index;
                        playMedia({manualPlay: true});
                    }
                }

                playBtn.oncontextmenu = evt => musicContextMenu(evt, id, index);
                
                playBtn.appendChild(playBtnText);
                playlist_main.appendChild(playBtn);

                updateTextScrollAnimation(playBtnText);
            })
        } else {
            playlist_main.innerHTML = `<div class='info'>您当前没有播放列表</div>`
        }
        
        popupWindow.appendChild(playlist_main)
    }
    async function uploadManager() {
        function updateUploadingProgress(elem, displayElem, status, progress, isFirstTime = false) {
            const progress_percent = Math.floor(Math.max(progress * 100, 0))
            elem.textContent = '上传进度: ' +
                status === 'pending' ? '正在上传文件' : 
                status === 'fragmenting' ? `正在进行文件分片, 进度${progress_percent}%` : 
                '上传已完成'
            displayElem.style.transform = `translateX(-${100-progress_percent}%)`;
            if(progress === 'finished' && !isFirstTime) getPlaylist()
        }

        popupWindow.innerHTML = `
        <div id='upload-manager-main'>
            <div id='loading' class='info'>正在加载上传记录</div>
        </div>`

        const user_upload_progress = await getUploadProgress();
        document.getElementById('loading').remove();
        const upload_manager_main = document.getElementById('upload-manager-main');
        if(user_upload_progress.length) {
            user_upload_progress.forEach(upload => {
                let { id, title, status, progress, playlist_id } = upload;
                let interval_id;

                const manageBlock = document.createElement('div');
                manageBlock.className = 'manage-block';

                const titleText = document.createElement('input');
                titleText.className = 'title';
                titleText.value = title;

                const statusText = document.createElement('div');
                statusText.className = 'status';
                
                if(status !== 'finished') {
                    interval_id = setInterval(async () => {
                        const updated_progress = await getUploadProgress(id);
                        if(!updated_progress.error_msg) {
                            status = updated_progress.status
                            progress = updated_progress.progress
                            updateUploadingProgress(statusText, statusDisplayBarBg, status, progress);
                        }
                        (!popupWindowVisibility || updated_progress.error_msg || updated_progress.status === 'finished') && clearInterval(interval_id)
                    }, 1000);
                }

                const statusDisplayBar = document.createElement('div');
                statusDisplayBar.className = 'progress-bar'

                const statusDisplayBarBg = document.createElement('div');
                statusDisplayBarBg.className = 'progress-bar-bg'
                statusDisplayBar.appendChild(statusDisplayBarBg);

                const renameBtn = document.createElement('div');
                renameBtn.className = 'function-btn clickable'
                renameBtn.textContent = '更新标题'
                renameBtn.onclick = async () => {
                    if(titleText.value && titleText.value !== title) {
                        const update_result = (await fetch(`/playlist/update-title`, {
                            method: 'POST',
                            body: JSON.stringify({ sessionID, id, title: titleText.value }),
                            headers: { 'Content-Type': 'application/json' }
                        })).json()
                        if(!update_result.error_msg && update_result) {
                            title = titleText.value;
                            showNotification(`[${title}] 更新标题成功!`, 'success')
                            getPlaylist();
                        } else  {
                            showNotification(`[${title}] 更新标题失败!`, 'error')
                        }
                    } else {
                        showNotification(`[${title}] 标题未改变!`)
                    }
                }

                const addToPlaylistBtn = document.createElement('div');
                addToPlaylistBtn.className = 'function-btn clickable'
                addToPlaylistBtn.textContent = '添加到播放列表'
                addToPlaylistBtn.onclick = () => {
                    roomMode.activate ?
                        roomMode.order.push(id) :
                        playStates.order.push(id);
                    roomMode.activate && roomMode.requestUpdatePlaylist();
                    showNotification('添加成功!')
                }

                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'function-btn clickable danger'
                deleteBtn.textContent = '删除此文件'
                let last_click = 0;
                deleteBtn.onclick = async () => {
                    if(status !== 'fragmenting') {
                        if(Date.now() - last_click > 10000) {
                            showNotification('请再点击一次以确认删除', 'info', 10000);
                            last_click = Date.now();
                        } else {
                            const delete_result = await (await fetch(`/playlist`, {
                                method: 'DELETE',
                                body: JSON.stringify({ sessionID, id }),
                                headers: { 'Content-Type': 'application/json' }
                            })).json()
                            if(!delete_result.error_msg && delete_result) {
                                showNotification(`成功删除 [${title}]!`, 'success');
                                manageBlock.remove();
                                getPlaylist();
                                if(interval_id) clearInterval(interval_id);
                            } else {
                                showNotification(`删除 [${title}] 失败!`, 'error');
                            }
                        }
                    } else {
                        showNotification('文件分片时无法删除, 请等待分片完成!', 'warn')
                    }
                }

                manageBlock.appendChild(titleText);
                manageBlock.appendChild(statusText);
                manageBlock.appendChild(statusDisplayBar);
                manageBlock.appendChild(renameBtn);
                manageBlock.appendChild(deleteBtn);
                manageBlock.appendChild(addToPlaylistBtn);
                upload_manager_main.appendChild(manageBlock);

                updateUploadingProgress(statusText, statusDisplayBarBg, status, progress, true);
            })
        } else {
            upload_manager_main.innerHTML = "<div class='info'>暂无上传记录!</div>"
        }

    }
    function room(roomCode = null) {
        const ws_urls = /^(http|https):\/\/([^\/]*).*$/.exec(window.location.href).slice(1, 3)
        const ws = new WebSocket(`ws${ws_urls[0] === 'https' ? 's' : ''}://${ws_urls[1]}/ws/room`);
        let userID, roomID, joined_users = [], master = null;

        function handleMessage(msg) {
            switch(msg.msgType) {
                case 'joined-room':
                    if(msg.content.userID) {
                        joinedRoom(msg.content)
                        showNotification(`已成功加入房间${roomID}!`)
                    } else {
                        showNotification(`用户${msg.content.userName}已加入房间!`)
                    }
                    syncPlaylist(msg.content);
                    break;
                case 'room-created':
                    master = msg.content.userName
                    joined_users = [master]
                    joinedRoom(msg.content)
                    roomMode.order = playStates.order;
                    roomMode.playlist = playStates.playlist;
                    showNotification(`已成功创建房间, 房间号为: ${roomID}`)
                    break;
                case 'sync-info':
                    syncInfo(msg.content)
                    break;
                case 'sync-progress':
                    syncProgress(msg.content);
                    break;
                case 'update-play-way':
                case 'update-playlist':
                    syncPlaylist(msg.content)
                    break;
                case 'update-too-frequent':
                    showNotification('跳的太快啦, 大家要跟不上了啦')
                    break;
                case 'ejection':
                    showNotification('房间的连接已被拒绝!', 'warning')
                    closeConnection(); return;
                case 'session-end':
                    showNotification('已离开房间, 返回单人模式')
                    closeConnection(); return;
                case 'room-not-exist':
                    showNotification('请求加入的房间不存在, 请确认您输入的房间号是否正确', 'warning')
                    closeConnection(); return;
                default: return;
            }
        }

        function joinedRoom(content) {
            userID = content.userID;
            roomID = content.roomID;
            roomMode.activate = true;
            roomMode.syncProgress = sendCurrentInfo;
            roomMode.exitRoom = exitRoom;
            roomMode.requestUpdatePlaylist = requestUpdatePlaylist;
            updateJoinRoomMenu()
        }

        function closeConnection() {
            ws.close();
        }

        function syncInfo({ users, master: room_master }) {
            joined_users = users;
            master = room_master;
            updateUserList(document.getElementById('room-users'))
            sendCurrentInfo('respond-sync')
        }

        function syncPlaylist({playlistOrder, playlistInfo, howToPlay, playlistIdx}) {
            roomMode.order = playlistOrder;
            playStates.how = howToPlay;
            playStates.playing = 
                playlistIdx >= 0 ? playlistIdx : 
                playStates.playing >= 0 ? playStates.playing : -1
            if(playlistInfo) {
                for(const media of playlistInfo) roomMode.playlist[media.id] = media;
            }
        }

        function syncProgress(waiting_sync) {
            const { playlistIdx, progress, isPaused } = waiting_sync;
            playStates.playing = playlistIdx;
            playMedia({startPlay: !isPaused});
            displaying.elem.currentTime = progress
            updatePlayIcon();
        }

        function requestUpdatePlaylist(wayOnly = false) {
            // send update request
            if(wayOnly) {
                ws.send(JSON.stringify({
                    msgType: 'switch-play-way',
                    roomID, userID,
                    content: { 
                        howToPlay: playStates.how,
                        playlistID: roomMode.order[playStates.playing],
                    }
                }))
            } else {
                ws.send(JSON.stringify({
                    msgType: 'update-playlist',
                    roomID, userID,
                    content: { 
                        playlist: roomMode.order,
                        playlistIdx: playStates.playing
                    }
                }))
            }
        }

        function sendCurrentInfo(msgType = 'sync') {
            ws.send(JSON.stringify({
                roomID, userID, msgType,
                content: {
                    playlistIdx: playStates.playing,
                    progress: displaying.elem ? displaying.elem.currentTime : 0,
                    isPaused: displaying.elem ? displaying.elem.paused : true,
                    date: Date.now()
                }
            }))
        }

        function exitRoom() {
            ws.send(JSON.stringify({ roomID, userID, msgType: 'exit-room' }))
        }

        ws.onopen = () => {
            const sendContent = { sessionID, playlist: playStates.order, how: playStates.how }
            if(roomCode) sendContent.requestRoomID = roomCode
            ws.send(JSON.stringify({
                msgType: roomCode ? 'join-room' : 'create-room',
                content: sendContent
            }))
        }

        ws.onmessage = msg => {
            handleMessage(JSON.parse(msg.data));
        }

        ws.onerror = err => {
            console.error(err);
        }

        ws.onclose = () => {
            roomMode.activate = false;
            roomMode.syncProgress = null;
            roomMode.exitRoom = null;
            roomMode.requestUpdatePlaylist = null;
            roomMode.playlist = {};
            roomMode.order = [];
            roomMode.extra = {};

            if(popupWindowVisibility) showPopup(roomPopup);
            const join_room_menu = document.getElementById('join-room-menu')
            join_room_menu.onclick = () => showPopup(roomPopup);
            join_room_menu.firstElementChild.textContent = '创建/加入房间';
            
            showNotification('与房间的连接已断开');
        }

        function updateUserList(container) {
            if(container) {
                if(!master) {
                    container.innerHTML = '<div class="room-info">正在等待同步房间信息</div>'
                } else {
                    container.innerHTML = joined_users.map(user=>{
                        const isMaster = user === master;
                        return `<div class='user${isMaster ? ' master' : ''}'>${user}${isMaster ? '(房主)' : ''}</div>`
                    }).join('');
                }
            }
        }

        function updateJoinRoomMenu() {
            function newRoomPopup() {
                popupWindow.innerHTML = 
                `<div class='room-popup'>
                    <div id='room-users' class='clickable'></div>
                    <div class='room-info'>您当前所在的房间号是<strong>${roomID}</strong></div>
                    <button id='exit-room' class='clickable'>离开房间</button>
                </div>`

                document.getElementById('exit-room').onclick = () => {
                    exitRoom();
                }

                const room_users_div = document.getElementById('room-users');
                room_users_div.onclick = () => {
                    if(room_users_div.classList.toggle('expanded')) {
                        updateUserList(room_users_div);
                    }
                }
            }
            const join_room_menu = document.getElementById('join-room-menu')
            join_room_menu.onclick = () => showPopup(newRoomPopup)
            join_room_menu.firstElementChild.textContent = '查看/离开房间';
            showPopup(newRoomPopup);
        }
    }
    function roomPopup() {
        popupWindow.innerHTML = 
        `<div class='room-popup'>
            <button class='clickable' id='create-room'>点击创建房间</button>
            <form id='join-room' autocomplete='off'>
                <input type='text' name='room-code' placeholder='房间号'>
                <button class='clickable' type='submit'>加入房间</button>
            </form>
        </div>
        `

        document.getElementById('create-room').onclick = () => {room(null)};
        document.getElementById('join-room').onsubmit = evt => {
            evt.preventDefault();
            const code = evt.target['room-code'].value;
            if(!code || !/^[0-9]{4}$/.test(code)) {
                showNotification('请填写正确的房间号以加入');
            } else {
                room(code);
            }
        }
        
    }
    function pauseTimer() {
        function millisecondToMinute(millisecond) {
            const seconds = Math.round(millisecond / 1000)
            const minute = `${Math.floor(seconds / 60)}`.padStart(2, '0')
            const second = `${seconds % 60}`.padStart(2, '0')
            return `${minute}:${second}`
        }

        function updateTimeLeft() {
            if(pause_after && popupWindowVisibility) requestAnimationFrame(updateTimeLeft)
            if(pause_after) {
                const now = Date.now();
                if(now >= pause_after) {
                    pauseTimerAction();
                    pauseTimerInfo.textContent = '已停止播放';
                } else {
                    pauseTimerInfo.textContent = `将在${millisecondToMinute(pause_after - now)}后停止播放`;
                }
            } else {
                pauseTimerInfo.textContent = '当前还未设置定时关闭'
            }
        }

        function setTimer(minutes) {
            if(!pause_after) requestAnimationFrame(updateTimeLeft);
            pause_after = Date.now() + Math.floor(minutes * 60000);
        }
        popupWindow.innerHTML = ''
        const pauseTimerMain = document.createElement('div')
        pauseTimerMain.className = 'pause-timer-main'

        const pauseTimerInfo = document.createElement('div');
        pauseTimerInfo.className = 'info section';

        const preSetTimers = document.createElement('div');
        preSetTimers.className = 'pre-set-timers section'

        for(let i = 1; i <= 6; i++) {
            const timer_minutes = i*10;
            const preSetTimer = document.createElement('div');
            preSetTimer.className = 'timer clickable';
            preSetTimer.textContent = timer_minutes;
            preSetTimer.onclick = () => setTimer(timer_minutes);
            preSetTimers.appendChild(preSetTimer)
        }

        const customTimerForm = document.createElement('form');
        customTimerForm.className = 'custom-timer-form section';
        customTimerForm.innerHTML = 
        `<span>自定义<input name='customer-timer' type='text' value='${
            localStorage.getItem('custom-pause-play-timer') || 45
        }'>分钟后停止</span>`
        customTimerForm.onsubmit = evt => {
            evt.preventDefault();
            const value = + evt.target['customer-timer'].value
            if(!value || value < 1 || value > 1440) {
                showNotification('自定义时间应为1-1440中的数字!');
                return;
            }
            localStorage.setItem('custom-pause-play-timer', value);
            setTimer(value);
        }

        const submitBtn = document.createElement('button')
        submitBtn.className = 'clickable'
        submitBtn.type = 'submit';
        submitBtn.textContent = '设定计时器'

        const cancelBtn = document.createElement('button')
        cancelBtn.className = 'clickable'
        cancelBtn.type = 'button';
        cancelBtn.textContent = '取消计时器'
        cancelBtn.onclick = () => { pause_after = 0 }

        customTimerForm.appendChild(submitBtn)
        customTimerForm.appendChild(cancelBtn)

        pauseTimerMain.appendChild(pauseTimerInfo);
        pauseTimerMain.appendChild(preSetTimers);
        pauseTimerMain.appendChild(customTimerForm);
        popupWindow.appendChild(pauseTimerMain);

        requestAnimationFrame(updateTimeLeft)
    }

    document.getElementById('user-center').onclick = () => {showNotification('这个功能还在开发中~')}
    document.getElementById('get-playlist').onclick = () => showPopup(showPlaylist);
    document.getElementById('pause-timer').onclick = () => showPopup(pauseTimer);
    document.getElementById('upload-media').onclick = () => showPopup(uploadMediaFile);
    document.getElementById('upload-manager').onclick = () => showPopup(uploadManager);
    document.getElementById('join-room-menu').onclick = () => showPopup(roomPopup);
    document.getElementById('update-playlist').onclick = async () => { await getPlaylist(); showNotification('更新完成') };
    document.getElementById('logout').onclick = () => {
        // clean up
        closePopup();
        Cookies.remove('session-id');
        window.removeEventListener('resize', windowResized);
        document.removeEventListener('keydown', keyboardControl);
        roomMode.activate && roomMode.exitRoom();
        // process to login
        askLogin();
        showNotification('登出成功!', 'success')
    }
    
    // init
    // load playlist info on load
    getPlaylist();
    // check if party page should overflow
    checkPartyOverflow();
}

// SECTION: start
document.onerror = err => { showNotification(err.message, 'error') }
askLogin();
}
        </script>
        <style type="text/css">
/* global */

body {
    margin: 0;
    padding: 0;
}

div {
    display: block;
    box-sizing: border-box;
}

#main {
    width: 100vw;
    height: 100vh;
    max-height: -webkit-fill-available;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1;
    overflow-y: auto;
}

.clickable:hover {cursor: pointer;}

@keyframes music-title-scroll {
from { transform: translateX(var(--music-title-size)); }
to { transform: translateX(-100%); }
}

@media screen and (min-width: 1024px) {
    ::-webkit-scrollbar {width: 7px;}
    ::-webkit-scrollbar-track {background-color: rgb(240, 240, 240);}
    ::-webkit-scrollbar-thumb {background-color: rgb(160, 160, 160); border-radius: 3px;}
    ::-webkit-scrollbar-thumb:hover {background-color: grey;}
}

/* notifications */

#popup-container,
#context-menu-container {
    width: 100vw;
    height: 100vh;
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
}

.toastify {
    min-width: 20%;
    max-width: 20%;
    height: fit-content;
    background: unset;
    font-size: 15px;
    padding: 20px;
    border-radius: 7px;
    text-align: center;
}

.toastify .toast-close {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    opacity: 0;
    display: block;
}

.toastify.info { background: dodgerblue; }
.toastify.success { background: limegreen; }

.toastify.err,
.toastify.error { background: red; }

.toastify.warn,
.toastify.warning { background: gold; text-shadow: 1px 1px 2px black; }


/* popup */
#popup-container {
    z-index: 50;
    transition-duration: .3s;
}

#popup-container #popup-window {
    position: absolute;
    transform: scale(0);
    transform-origin: center;
    transition-duration: .3s;
    width: 50%;
    height: 50%;
    margin: 15vh 25%;
    background-color: white;
    border: 1px solid gray;
    border-radius: 7px;
    pointer-events: initial;
    overflow-y: auto;
    padding: 20px;
}

/* context menu */
#context-menu-container {
    z-index: 100;
    --menu-width: 300px;
}
#context-menu-container .context-menu {
    width: var(--menu-width);
    height: fit-content;
    padding: 20px;
    border: 1px solid black;
    border-radius: 7px;
    pointer-events: initial;
    background-color: white;
    position: fixed;
}
#context-menu-container .context-menu .item {
    width: 100%;
    border-radius: inherit;
    height: fit-content;
    font-size: 17px;
    padding: 10px;
}
#context-menu-container .context-menu .item:hover {
    background-color: #ededed;
    cursor: pointer;
}
#context-menu-container .context-menu.playlist-context-menu {
    transform-origin: top center;
    transform: scaleY(0);
    user-select: none;
}
/* login */

#login-form {
    --input-width: 25vw;
    --input-height: 50px;
    --show-pass-icon-height: 25px;

    width: fit-content;
    max-width: calc(var(--input-width) + 30px);
    height: fit-content;
    display: block;
    position: relative;
    margin: auto;
    margin-top: 20vh;
    text-align: center;
    margin-bottom: 50px;
}
    
#login-form #show-password {
    position: absolute;
    height: var(--input-height);
    width: var(--input-height);
    margin-left: calc(var(--input-width) - var(--input-height));
    padding: calc((var(--input-height) - var(--show-pass-icon-height)) / 2);
}
#login-form #show-password i {
    display: block;
}

#login-form .remember-password-container {
    display: flex;
    align-items: center;
    margin-bottom: 20px;
    align-items: center;
}
#login-form .remember-password-container span {
    display: inline-block;
    margin: auto;
    margin-left: 5px;
}
#login-form .remember-password-container input {
    display: inline-block;
    margin: auto;
    margin-right: 5px;
    width: 20px;
    height: 20px;
}
#login-form input:not(input[type='checkbox']) {
    width: var(--input-width);
    height: var(--input-height);
    border: 1px solid black;
    border-radius: 10px;
    display: block;
    margin: 20px auto;
    padding: 0 20px;
    box-sizing: border-box;
}
#login-form input:focus {outline: none;}
#login-form button {
    width: calc(var(--input-width) - 50px);
    height: calc(var(--input-height) - 10px);
    box-sizing: border-box;
    border-radius: 10px;
    border: 1px solid black;
    background-color: red;
    color: white;
    font-size: 17px;
    transition-duration: .5s;
}
#login-form button:hover {
    background-color: crimson;
}


/* party */
#party {
    --nav-bar-width: 50px;
    --nav-bar-item-width: 200px;
    --nav-bar-left-padding: 35px;
    --nav-bar-right-padding: 5px;
    --media-container-height: 500px;
    --controllers-height: 30px;
    
    position: fixed;
    height: 100%;
    width: 100%;
}

#party #nav-bar {
    width: calc(var(--nav-bar-item-width) + var(--nav-bar-width) + var(--nav-bar-left-padding) + var(--nav-bar-right-padding) + 7px);
    height: 100%;
    position: fixed;
    top: 0;
    left: 0;
    border-right: 1px solid grey;
    padding: 50px var(--nav-bar-right-padding) 0px var(--nav-bar-left-padding);
    transform: translateX(calc(0px - (100% - var(--nav-bar-width))));
    transition-duration: .5s;
    z-index: 5;
    overflow-y: auto;
    background-color: white;
}

#party #nav-bar #hamburger-icon {
    width: 40px;
    height: 40px;
    color: grey;
    position: absolute;
    right: 5px;
    top: 5px;
}
#party #nav-bar #hamburger-icon i {
    font-size: 26px;
    margin: 7px;
}

#party #nav-bar .items {
    height: calc(100% - 50px);
    width: fit-content;
    position: absolute;
    bottom: 0;
    scrollbar-width: none;
    overflow-y: auto;
}

#party #nav-bar .items ::-webkit-scrollbar {display: none;}

#party #nav-bar .items .item {
    width: var(--nav-bar-item-width);
    padding: 10px;
    border-radius: 7px;
    min-height: 55px;
    display: flex;
    align-items: center;
}
#party #nav-bar .items .item div {
    margin: auto;
}
#party #nav-bar .items .item:hover {
    background-color: #ededed;
}
#party #nav-bar.expanded-nav-bar {
    transform: unset !important;
}

#party .party-main {
    height: fit-content;
    width: calc(100% - var(--nav-bar-width));
    position: relative;
    left: var(--nav-bar-width);
    top: 0;
}

#party .media-container-block {
    margin-top: 10px;
    position: relative;
    width: 100%;
    height: var(--media-container-height);
}

#party .media-container-block .media-container {
    display: flex;
    width: 100%;
    height: 100%;
    align-items: center;
}

#party .media-container-block .media-container .music-title-container {
    --music-title-size: calc(var(--media-container-height) - 100px);

    position: relative;
    margin: auto;
    width: var(--music-title-size);
    height: var(--music-title-size);
}

#party .media-container-block .media-container 
.music-title-container .music-title {
    --music-title-content-height: calc(var(--media-container-height) / 4);
    position: absolute;
    width: calc(var(--music-title-size) - 50px);
    text-align: center;
    color: white;
    font-size: calc(var(--music-title-content-height) / 2);
    z-index: 2;
    height: var(--music-title-content-height);
    line-height: var(--music-title-content-height);
    margin-top: calc((var(--music-title-size) - var(--music-title-content-height)) / 2);
    margin-left: 25px;
    -webkit-text-stroke: 1px black;
    overflow: hidden;
}

#party .media-container-block .media-container 
.music-title-container .music-title .music-title-text {
    animation-name: music-title-scroll;
    animation-iteration-count: infinite;
    animation-timing-function: linear;
    text-wrap: nowrap;
    width: fit-content;
    user-select: none;
}

#party .media-container-block .media-container #video-component,
#party .media-container-block .media-container #audio-component {
    max-height: 100%;
    max-width: 100%;
    
    margin: auto;
    display: none;
}
    
#party .media-container-block .media-container i {
    font-size: var(--music-title-size);
    color: rgb(50 50 50);
    display: block;
    height: 100%;
    width: 100%;
    position: absolute;

}
#party .media-container-block .media-container i::before {
    vertical-align: 1em;
}

#party .media-interactive-container {
    --media-progress-container-padding: 15px;
    --media-progress-bar-height: 6px;

    position: relative;
    width: 50%;
    margin: auto;
    margin-bottom: 20px;
    height: calc(var(--media-progress-container-padding) * 2 + var(--media-progress-bar-height));
    padding: var(--media-progress-container-padding) 0px;
    user-select: none;
    
    --media-progress-bar-elem-width: 100%;
}

#party .media-interactive-container .bar {
    position: absolute;
    width: var(--media-progress-bar-elem-width);
    height: var(--media-progress-bar-height);
    background-color: lightgray;
    border-radius: 10px;
    overflow: hidden;
    pointer-events: none;
}

#party .media-interactive-container .bg {
    position: absolute;
    width: var(--media-progress-bar-elem-width);
    height: var(--media-progress-bar-height);
    border-radius: 10px;
    background-color: red;
    transform-origin: right center;
    left: calc(0px - var(--media-progress-bar-elem-width));
}

#party .media-interactive-container #node {
    position: absolute;
    left: -7px;
    pointer-events: none;
    top: 11px;
    width: 14px;
    height: 14px;
    background-color: white;
    border: 1px solid black;
    border-radius: 15px;
}
#party .media-interactive-container i {
    position: absolute;
    font-size: 21px;
    top: 3px;
    left: -30px;
}
#party .media-interactive-container i:last-child {
    right: -30px;
    left: unset;
}
#party .media-interactive-container i:hover {
    cursor: default;
}
#party .media-interactive-container#media-volume-interactive { width: 30%; margin-top: 20px; }

#party .controllers {
    margin-top: 10px;
    position: relative;
    width: 100%;
    height: fit-content;
    text-align: center;
    display: flex;
    align-items: center;
}

#party .controllers .controller {
    display: inline-block;
    margin: 0px 5px;
}
#party .controllers .controller i {
    font-size: var(--controllers-height);
    line-height: var(--controllers-height);
}
#party .controllers .controller:first-child {
    margin-left: auto;
}
#party .controllers .controller:last-child {
    margin-right: auto;
}
#party .controllers .controller.sub-icon i {
    font-size: calc(var(--controllers-height) - 10px);
}

#party .overflow-observer {
    position: relative;
    width: 100%;
    height: 10px;
}
#party .overflow-observer:first-child {
    position: absolute;
}

/* popup windows */
#upload-media-container .upload-file-container {
    position: relative;
    margin: auto;
    width: 100%;
    height: 300px;
    border: 20px dashed lightgray;
    border-radius: 10px;
}

#upload-media-container .upload-file-container .show-upload,
#upload-media-container .upload-file-container #files-input {
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
    border-radius: inherit;
}

#upload-media-container .upload-file-container .show-upload {
    z-index: 1;
    display: flex;
    align-items: center;
}
#upload-media-container .upload-file-container .show-upload span {
    display: block;
    margin: auto;
    font-size: 30px;
    font-weight: 500;
    color: gray;
}

#upload-media-container .upload-file-container #files-input {
    opacity: 0;
    z-index: 2;
    box-sizing: border-box;
}

#upload-media-container .progress-bar {
    --progress-bar-height: 40px;

    width: 100%;
    height: var(--progress-bar-height);
    border-radius: 10px;
    border: 1px solid lightgray;
    margin: auto;
    margin-top: 20px;
    position: relative;
    overflow: hidden;
}

#upload-media-container .progress-bar .progress-text, 
#upload-media-container .progress-bar input,
#upload-media-container .progress-bar .progress-background {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    border: unset;
    padding: 0px 20px;
    border-radius: inherit;
    box-sizing: border-box;
}

#upload-media-container .progress-bar .progress-text {
    line-height: var(--progress-bar-height);
    user-select: none;
    text-wrap: nowrap;
    min-width: 100%;
    width: fit-content;
}
#upload-media-container .progress-bar .progress-background {
    z-index: 1;
    border-radius: unset;
    padding: unset;
    transform: translateX(-100%);
    background-color: lightgreen;
}

#upload-media-container .progress-bar .remove-file {
    position: absolute;
    z-index: 2;
    right: 0;
    height: var(--progress-bar-height);
    width: var(--progress-bar-height);
    top: 0;
    display: flex;
}
#upload-media-container .progress-bar .remove-file i {
    margin: auto;
}

#upload-media-container .btn-container {
    width: 100%;
    height: fit-content;
    margin-top: 20px;
    display: flex;
}
#upload-media-container .btn-container button {
    display: inline-block;
    width: 100%;
    height: 40px;
    margin: 0 10px;
    border-radius: 10px;
    border: none;
    background-color: dodgerblue;
    color: white;
    font-size: 17px;
    box-sizing: border-box;
}
#upload-media-container .btn-container button:hover {cursor: pointer;}
#upload-media-container .btn-container button:first-child { margin-left: unset; }
#upload-media-container .btn-container button:last-child { margin-right: unset; }

#playlist-main {
    --media-height: 50px;
    --focus-color: #ededed;
}

#playlist-main .media {
    width: 100%;
    height: var(--media-height);
    line-height: var(--media-height);
    border-radius: 5px;
    padding: 0px 5px;
    overflow: hidden;
    user-select: none;
}
#playlist-main .edit-playlist {
    width: fit-content;
    height: fit-content;
    margin: 10px 5px;
}
#playlist-main .edit-playlist i {
    color: dodgerblue;
    font-size: 20px;
}
#playlist-main .media.bulk-selected {
    border: 1px solid red;
    margin-bottom: 3px;
}
#playlist-main .media * {
    pointer-events: none;
}

#playlist-main .media .title-text {
    text-wrap: nowrap;
    width: fit-content;
}
#playlist-main .media:hover {
    background-color: var(--focus-color);
}

#playlist-main .playing {
    background-color: var(--focus-color);
    color: red;
}
#playlist-main .playing:hover {
    background-color: #e0e0e0;
}

#playlist-main .info {
    text-align: center;
    font-size: 30px;
    margin-top: 10vh;
}

#upload-manager-main .info {
    text-align: center;
    font-size: 30px;
    margin-top: 10vh;
}

#upload-manager-main .manage-block {
    margin: 20px 0px;
    padding: 20px 5px;
    border-bottom: 1px dashed grey;
}

#upload-manager-main .manage-block .title {
    width: calc(100% + 10px);
    height: 50px;
    padding: 0px 15px;
    box-sizing: border-box;
    font-size: 17px;
    border-radius: 7px;
    border: 1px solid;
    margin-left: -5px;
}

#upload-manager-main .manage-block .status {
    margin: 20px 0px 5px 0px;
}

#upload-manager-main .manage-block .progress-bar {
    width: 100%;
    height: 7px;
    border: 1px solid;
    border-radius: 5px;
    overflow: hidden;
    position: relative;
}

#upload-manager-main .manage-block .progress-bar .progress-bar-bg {
    width: 100%;
    height: 100%;
    position: absolute;
    transform: -100%;
    background-color: lightgreen;
}

#upload-manager-main .manage-block .function-btn {
    display: inline-block;
    margin-top: 20px;
    border-radius: 10px;
    margin-right: 40px;
    user-select: none;
}
#upload-manager-main .manage-block .function-btn.danger {
    color: red;
}

#upload-manager-main .manage-block:first-child {
    margin-top: unset;
}

#upload-manager-main .manage-block:last-child {
    border-bottom: unset;
    margin-bottom: unset;
}
#upload-manager-main .manage-block:first-child {margin-top: unset;}
#upload-manager-main .manage-block:last-child {margin-bottom: unset;}

.room-popup { padding-top: 30px; }
.room-popup .room-info {
    font-size: 25px;
    text-align: center;
    display: block;
    margin-bottom: 30px;
}
.room-popup button, .room-popup input[type='text'] {
    width: 70%;
    display: block;
    height: 55px;
    font-size: 20px;
    border-radius: 10px;
    border: 1px solid;
    margin: auto;
    margin-bottom: 20px;
    background-color: dodgerblue;
    color: white;
}
.room-popup input[type='text'] {
    box-sizing: border-box;
    text-align: center;
    background: initial;
    color: initial;
    margin-top: 50px;
}
.room-popup #room-users {
    position: absolute;
    width: 35%;
    height: 100%;
    top: 0;
    padding: 20px 30px;
    border-radius: 5px;
    background-color: white;
    left: 0;
    transition-duration: .5s;
    transform: translateX(calc(30px - 100%));
    box-shadow: 5px 5px 10px gray;
}
.room-popup #room-users.expanded {
    transform: unset;
}
.room-popup #room-users .user {
    font-size: 20px;
    margin-bottom: 10px;
    user-select: none;
}
.room-popup #room-users .user.master {
    color: orange;
}

.pause-timer-main {
    --pre-set-timer-size: 60px;
    --pre-set-timers-margin: 20px;
    --section-width: calc(var(--pre-set-timer-size) * 6 + var(--pre-set-timers-margin) * 5);
    --common-font-size: 20px;
}

.pause-timer-main .info {
    text-align: center;
    font-size: calc(var(--common-font-size) * 1.5);
}

.pause-timer-main .pre-set-timers {
    display: flex;
    margin: auto;
    width: var(--section-width);
}

.pause-timer-main .pre-set-timers .timer {
    margin: auto;
    border: 3px solid black;
    text-align: center;
    user-select: none;

    width: var(--pre-set-timer-size);
    height: var(--pre-set-timer-size);
    line-height: calc(var(--pre-set-timer-size) - 3px);
    font-size: calc(var(--pre-set-timer-size) / 3);
    border-radius: var(--pre-set-timer-size);
}

.pause-timer-main .custom-timer-form {
    margin: auto;
    width: var(--section-width);
    text-align: center;
}
.pause-timer-main .custom-timer-form span {
    font-size: var(--common-font-size);
    display: block;
}
.pause-timer-main .custom-timer-form input {
    width: 50px;
    height: fit-content;
    font-size: var(--common-font-size);
    text-align: center;
    box-sizing: border-box;
    border: none;
    border-bottom: 1px solid black;
    padding: 0px;
}
.pause-timer-main .custom-timer-form input:focus {
    outline: none;
}
.pause-timer-main .custom-timer-form button {
    width: 40%;
    height: calc(var(--common-font-size) * 2);
    margin: 20px;
    border: 1px solid;
    border-radius: 7px;
    font-size: var(--common-font-size);
}
.pause-timer-main .section {
    margin-top: 30px;
}
/* mobile view */
@media screen and (max-width: 1023px) {
    .toastify {
        min-width: 50%;
        max-width: 50%;
        height: fit-content;
        font-size: 40px;
        border-radius: 15px;
    }

    #popup-container #popup-window {
        width: 90%;
        margin: 25% 5%;
        border-radius: 15px;
    }

    #context-menu-container {
        --menu-width: 400px;
    }
    #context-menu-container .context-menu .item {
        font-size: 35px;
    }

    #login-form {
        --input-width: 90vw;
        --input-height: 100px;
        --show-pass-icon-height: 50px;
        font-size: 50px;
    }

    #login-form #show-password i::before {
        vertical-align: 1em;
    }
    #login-form .remember-password-container input {
        margin-right: 15px;
        width: 40px;
        height: 40px;
    }
    #login-form button {
        font-size: 35px;
        border-radius: 15px;
    }
    #login-form input:not(input[type='checkbox']) {
        border-radius: 15px;
        padding: 0 40px;
        font-size: 35px;
    }

    #playlist-main {
        --media-height: 100px;
    }

    #playlist-main .media {
        border-radius: 15px;
    }
    
    #playlist-main .media .title-text {
        font-size: 40px;
    }

    #playlist-main .info {
        font-size: 40px;
    }


    #party {
        --nav-bar-width: 0px;
        --media-container-height: 800px;
        --controllers-height: 60px;
    }

    #party #nav-bar {
        width: 100%;
        height: fit-content;
        position: relative;
        transform: none;
        border-right: unset;
        padding: var(--nav-bar-left-padding);
        overflow: unset;
        transition-duration: unset;
    }

    #party #nav-bar #hamburger-icon {
        display: none;
    }

    #party #nav-bar .items {
        height: fit-content;
        width: 100%;
        position: relative;
    }

    #party #nav-bar .items .item {
        width: 100%;
        padding: 20px;
        border-radius: 15px;
        font-size: 40px;
    }

    #party #node {
        top: 25px !important;
        width: 25px !important;
        height: 25px !important;
        border-radius: 25px !important;
    }

    #party .party-main {
        position: relative;
    }

    #party .controllers .controller {
        margin: 0px 30px;
    }

    #party .media-interactive-container {
        --media-progress-container-padding: 30px;
        --media-progress-bar-height: 15px;
        width: 80%;
    }
    #party .media-interactive-container#media-volume-interactive {
        width: 50%;
    }
    #party .media-interactive-container#media-volume-interactive i {
        font-size: 40px;
        top: 8px;
        left: -50px;
    }
    #party .media-interactive-container#media-volume-interactive i:last-child {
        left: unset !important;
        right: -50px !important;
    }
    
    #party .media-container .music-title-container .music-title {
        -webkit-text-stroke: 2px black;
    }

    #playlist-main .edit-playlist i {
        font-size: 40px;    
    }

    #upload-media-container .upload-file-container {
        height: 500px;
    }

    #upload-media-container .upload-file-container .show-upload span {
        font-size: 50px;
    }

    #upload-media-container .progress-bar {
        --progress-bar-height: 100px;
        border-width: 5px;
    }
    #upload-media-container .progress-bar .progress-text {
        font-size: 30px;
    }

    #upload-media-container .progress-bar .remove-file i {
        font-size: 30px;
    }
    #upload-media-container .progress-bar .remove-file i::before {
        vertical-align: unset;
    }
    #upload-media-container .progress-bar input {
        font-size: 30px;
    }

    #upload-media-container .btn-container {
        display: block;
        margin-top: 30px;
    }
    #upload-media-container .btn-container button {
        margin: unset;
        margin-bottom: 20px;
        font-size: 30px;
        border-radius: 15px;
        display: block;
        height: 70px;
    }

    #upload-manager-main .manage-block .title {
        height: 100px;
        padding: 0px 20px;
    }
    #upload-manager-main .manage-block .progress-bar {
        height: 12px;
    }
    #upload-manager-main .manage-block * {
        font-size: 30px !important;
    }

    .room-popup .room-info {
        font-size: 45px;
        margin: 100px 0px;
    }
    .room-popup button, .room-popup input[type='text'] {
        width: 90%;
        height: 100px;
        font-size: 35px;
        margin-bottom: 30px;
    }
    .room-popup input[type='text'] {
        margin-top: 100px;
    }
    .room-popup #room-users {
        width: 50%;
        padding: 30px 40px;
        border-radius: 15px;
        transform: translateX(calc(40px - 100%));
        box-shadow: 7px 7px 15px gray;
    }
    .room-popup #room-users .user {
        font-size: 40px;
        margin-bottom: 20px;
    }

    .pause-timer-main {
        --pre-set-timer-size: 100px;
        --pre-set-timers-margin: 30px;
        --common-font-size: 40px;
    }
    .pause-timer-main .custom-timer-form input {
        width: 100px;
    }
    .pause-timer-main .custom-timer-form button {
        margin: 30px;
        border: 3px solid;
        border-radius: 15px;
    }
    .pause-timer-main .section {
        margin-top: 50px;
    }
}
        </style>
        <title>音趴</title>
    </head>
    <body>
        <div id="context-menu-container"></div>
        <div id="notification-container"></div>
        <div id="popup-container"><div id="popup-window"></div></div>
        <div id="main"></div>
        <script type="text/javascript" src="src/toastify-js.js"></script>
    </body>
</html>